```text
[Controller] → [Service] → [Repository]
                          ↘ (예외 발생)
                            → 위로 전달됨
                              → @ControllerAdvice의 @ExceptionHandler가 잡음
```
즉, Service나 Repository에서는 try-catch가 없음

ExceptionHandler만 있음 → 결과는 보냈지만 예외 원인은 제어하지 않았다 [결과 처리]

*** 이 구조의 문제점은? ***
    예외 발생지 추적이 어렵다
    모든 예외가 ExceptionHandler까지 올라가면, 상세 제어가 불가능
    도메인 의미에 맞는 예외를 표현하지 못함
    비즈니스 정책과 무관한 기술적 예외 처리만 하게 돼

*** 실무적인 예외 처리 구조 ***
    각 계층은 자기 책임만큼 예외를 처리해야 한다
    [Repository] : DB 오류 (보통은 던진다)
    [Service] : 비즈니스 정책 위반 -> Cuntom 예외 처리
    [Controller] : 요청-응답 사이드 처리 -> ExceptionHandler와 메시지 매핑

    1. 비즈니스 예외는 서비스 계층에서 처리 (try-catch 직접 작성)
        의도된 예외 > 사용자 잘못 or 예상된 조건 불만족 
            > 서비스 계층에서 직접 처리하고, 예외를 던지더라도 비즈니스 예외로 한정한다
        예외가 컨트롤러까지 도달할 경우, 사용자에게 메시지만 전달하는 방식으로 한다
    2. 예측 불가능한 시스템 예외는 전역 처리기에서 한번에 처리
        ex. DB 연결 오류, 파일 시스템 오류
        > 서버 로그 남기기
        > 공통 에러 페이지 보내기
        > 사용자가 뭘 잘못했는지 모를 때
    3. 컨트롤러에서 파라미터 이상 등은 Web 레벨에서 처리
        컨트롤러에서는 가급적 try-catch문은 자제한다
        컨트롤러의 책임은 흐름 제어와 뷰 반환   // 예외 처리가 아니다!