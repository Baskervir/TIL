SQL을 직접 다룰때 발생하는 문제점


[개요] 
데이터베이스에 데이터를 관리하려면 SQL을 사용해야 한다.
JDBC API를 사용해서 SQL을 데이터베이스에 전달

[항목1]
반복되는 문제점
테이블 이미 개발되어 있다는 가정하에 CRUD기능을 개발(회원관리기능)
먼저 Member객체를 만든다
객체를 데이터베이스에 관리할 목적으로 회원용 DAO(데이터 접근 객체)를 만든다

MemberDAO 의 find() 메서드를 완서앟여 회우너 조회 기능을 개발한다
    1. 회원 조회용 SQL을 작성
    2. JDBC API를 사용해서 SQL을 실행
    3. 조회 결과를 Member객체로 매핑
= "회원 조회" 가능해졌다.

회원 등록 기능을 추가
    1. 회원 등록용 SQL을 작성
    2. 회원 객체의 값을 꺼내서 등록 SQL에 전달
    3. JDBC API를 사용하여 SQL을 실행
= "회원 등록" 가능해졌다.

회원을 수정, 삭제 하는 기능 추가
위와 같은 작업을 반복해야 할 것이다

회원 객체를 데이터베이스가 아닌 자바 컬렉션에 보관한다면? > 컬렉션은 다음 한 줄로 객체를 저장할 수 있다
    list.add(member);
데이터베이스는 객체 구조와는 다른 데이터 중심의 구조를 가지므로 객체를 데이터베이스에 직접 저장, 조회 할 수 없다.
따라서 객체지향 App과 DB 중간에서 SQL과 JDBC API를 사용해서 변환 작업을 해줘야 한다.

[문제점]객체를 데이터베이스에 CRUD하려면 너무 많은 SQL과 JDBC API를 코드로 작성한다

[항목]
SQL에 의존적인 개발

회원의 연락처도 함께 저장해달라는 요구사항이 추가되었다.

[등록 코드 변경]
dto에 객체 추가
연락처 저장 할 수 있도록 INSERT SQL을 수정
[String sql = "INSERT INTO MEMBER(MEMBER_ID, NAME, TEL) VALUE(?,?,?)";]
연락처를 데이터베이스에 저장하기 위해 SQL과 JDBC API를 수정했다

[조회 코드 변경]
조회용 SQL 수정
[SELECT MEMBER_ID, NAME, TEL FROM MEMBER WHERE MEMBER_ID = ?]
연락처의 조회 결과를 Member 객체에 추가로 매핑한다
[...
String tel = rs.getString("TEL");
member.setTel(tel);
...]
이제서야 연락처 값이 화면에 출력된다.

[수정 코드 변경],[삭제 코드 변경]

[연관된 객체]
회원은 어떤 한 팀에 필수로 소속되어야 한다는 요구사항 추가

[문제점]
    A 객체가 연관된 B 객체를 사용 가능한지 여부는 사용하는 SQL에 달렸다
    데이터 접근 계츨을 사용해서 SQL을 숨겨도 어쩔 수 없이 DAO를 열어서 어떤 SQL이 실행되는지 확인해야 한다

Member, Team처럼 비즈니스 요구사항을 모델링한 객체를 [엔티티]라 한다

[SQL에 모든 것을 의존하는 상황 > 엔티티 신뢰 및 사용 불가?]

SQL의존이란?
    애플리케이션 로직이나 상태 판탄을 DB 쿼리로 직접 수행하고, 애플리케이션(자바 코드, 엔티티)에서는
    그냥 그 결과만 받아서 보여주는 경우

엔티티는 무지해진다
    [엔티티]는 본래 도메인 개념을 담고, 내부 상태와 로직을 책임지는 객체
    하지만 SQL 위주로 처리하면:
        엔티티는 그저 DB 테이블의 데이터 구조일 뿐
        중요한 판단(활성 사용자 여부, 상태 변경, 비즈니스 조건)은 모두 쿼리로 처리됨
        비즈니스 로직이 DB로 흧어지고, Java 코드는 "데이터 그릇"일 뿐이 된다

    [결론]
        테스트할 수 없다 (엔티티 단위 테스트 불가)
        재사용 불가 (비즈니스 판단이 SQL 안에 박혀있다
        도메인 규칙 변경 시 유지보수 어렵다

신뢰 불가능한 이유 요약
    [도메인 지식 없음] : 엔티티에 비즈니스 의미가 없다. 조건, 정책 모두 SQL에서만 존재
    [상태 추론 불가] : 자바 객체를 보더라도 어떤 상태인지 알 수 없다
    [테스트 불가] : 객체 단위 테스트가 아닌, DB 세팅 + SQL 테스트가 필요
    [변경에 취약] : 로직이 SQL에 하드코딩되어 수정이 어렵고 추적도 힘들다

[개선하기]
    도메인 로직은 Entity / Domain / Service Layer에서 처리
    SQL은 오직 데이터 조회 / 저장 역할만 한다

SQL 중심의 구조는 애플리케이션 계층의 역할을 약화
도메인 모델은 단순 데이터 구조가 된다
객체지향의 가장 큰 장점인 [행위와 데이터의 응집]을 잃는다


진정한 의미의 계층 분할이 어렵다. [?]
엔티티를 신뢰할 수 없다. [?]
SQL에 의존적인 개발을 피하기 어렵다 [v]

[항목]
JPA와 문제 해결

JPA가 문제를 어떻게 해결하는가?

직업 SQL 작성 X -> JPA가 제공하는 API를 사용
[개발자 대신 적절한 SQL을 생성하여 데이터베이스에 전달한다.]

[저장 기능]
jpa.persist(member); //저장
JPA가 객체와 매핑정보를 보고 적절한 INSERT SQL을 생성 > 데이터에비으세 전달

    [매핑 정보] : 어떤 객체를 어떤 테이블에 관리할지 정의한 정보

[조회 기능]
String memberId = "helloId";
Member member = jpa.find(Member.class, memberId);   //조회

[수정 기능]
Member member = jpa.find(Member.class, memberId);
member.setName("이름변경"); //수정
JPA는 별도의 수정 메서드를 제공하지 않는다.
객체를 조회해서 값을 변경해야 한다.
트랜잭션을 커밋할 때, 데이터베이스에 적절한 UPDATE SQL이 전달된다.

[객체와 관계형 데이터베이스의 패러다임 차이??]

[패러다임 불일치]
현대의 복잡한 애플리케이션은 대부분 객체지향 언어로 개발
[정의한 도메인 모델을 저장할 때 문제 발생]
예를 들어 특정 유저가 시스템에 회원 가입하면 회원이라는 객체 인스턴스를 생성한 후에 이 객체를 메모리가 아닌 어딘가에 영구 보관해야 한다.

객체는 속성(필드)과 기능(메서드)를 가진다.
객체의 기능은 클래스에 정의되어 있다

객체가 단순하면 객체의 모든 속성 값을 꺼내서 파일이나 데이터베이스에 저장하면 된다.
하지만, 부모 객체를 상속받았거나, 다른 객체를 참조하고 있다면 객체의 상태를 저장하기 어렵다.
회원 객체가 팀 객체를 참조하고 있다면, 회원 객체를 저장할 때 팀 객체도 함께 저장해야 한다.

[직렬화 기능??]

[관계형 데이터베이스는 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구한다.],
[객체지향에서 말하는 추상화, 상속, 다형성 같은 개념이 없다.]

[객체]와 [관계형 데이터베이스]는 지향하는 목적이 서로 다르다 > 기능과 표현법도 다르다
> "패러다임 불일치"

[패러다임 불일치로 인한 문제점]
상속
    객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없다
    슈퍼타입&서브타입 관계를 사용하면 상속과 유사한 형태로 테이블 설계[는] 가능

객체를 테이블에 맞추어 모델링
class Member {
    String id;  //MEMBER_ID 칼럼 사용
    Long teanId;    //TEAM_ID FK 칼럼 사용
    String username;    //USERNAME 칼럼 사용
}

class Team {
    Long id;    //TEAM_ID PK 사용
    String name;    //NAME 칼럼 사용
}

MEMBER 테이블의 칼럼을 그대로 가져와서 Member 클래스를 만들었다
객체를 테이블에 저장하거나 조회할 때는 편리하다
[TEAM_ID 외래 키의 값을 그대로 보관하는 teamId 필드에는 문제가 있다]
객체는 연관된 객체의 참조를 보관해야 다음처럼 참조를 통해 연관된 객체를 찾을 수 있다
    Team team = member.getTeam();
특정 회원이 소속된 팀을 조회하는 가장 객체지향적인 방법 [참조 사용]


객체지향 모델링
    객체는 참조를 통해서 관계를 맺는다
    객체지향 모델링을 사용하면 객체를 테이블에 저장하거나 조회하기가 쉽지 않다
    Member 객체는 team 필드로 연관관계를 맺고, MEMBER 테이블은 TEAM_ID 외래 키로 연관관계를 맺기 때문이다
    객체 모델은 외래 키가 필요 없고 단지 참조만 있으면 된다
    [테이블은 참조가 필요 없고 외래 키만 있으면 된다]
개발자가 중간에서 변환 역할을 해야한다
member.getTeam().getId()
[
member.getId(); //MEMBER_ID PK에 저장
member.getTeam().getId();   //TEAM_ID FK에 저장
member.getUsername();   //USERNAME 칼럼에 저장
]

객체를 데이터베이스에 저장하려면 team 필드를 TEAM_ID 외래 키 값으로 변환 해야 하며,
조회할 때는 TEAM_ID 외래 키 값을 Member 객체의 team 참조로 변환해서 객체에 보관해야 한다
[
SELECT M.*, T.*
    FROM MEMBER M
    JOIN TEAM T ON M.TEAM_ID - T.TEAM_ID
]

JPA와 연관관계
[JPA는 연관관계와 관련된 패러다임 불일치 문제를 해결해준다]
참조를 외래 키로 변환해서 적절한 INSERT SQL을 데이터베이스에 전달
객체 조회할 때 외래 키를 참조로 변환하는 일도 한다

객체 그래프 탐색
객체에서 조회는 참조를 사용해서 연관 관계를 찾는다
[객체 그래프 탐색]

[SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다]

JPA를 사용하면 객체 그래프를 탐색할 수 있다
실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룬다고 하여 [지연 로딩]이라 한다

이러한 기능들을 사용하기 위해 객체에 JPA와 관련된 어떤 코드들을 심어야 할까?
[JPA는 지연 로딩을 투명하게 처리한다]

[비교]
데이터베이스는 기본 키의 값으로 각 로우(row)를 구분한다
반면에 객체는 [동일성 비교]와 [동등성 비교]라는 두 가지 비교 방법이 있다.

[동일성 비교] : ==비교, 객체 인스턴스의 주소 값을 비교
[동등성 비교] : equals() 메서드 사용, 객체 내부의 값을 비교

따라서, 테이블의 로우를 구분하는 방법과 객체를 구분하는 방법에는 차이가 있다.

[포인트 정리]
DB 테이블의 로구 구분 방식
    기본 키(PK)를 기준으로 row를 식별한다

[SELECT * FROM member WHERE id = 100;]
    이건 항상 같은 row
    그래서 DB에서는 "이건 같은 애"라고 인식

자바 객체의 구분 방식
    기본적으로 new키워드로 만든 인스턴스는 서로 다른 존재
    아무리 필드값이 같아도 ==은 false

Member m1 = new Member("100", "홍길동");
Member m2 = new Member("100", "홍길동");

System.out.println(m1 == m2);   // false (주소 다름)
System.out.println(m1.equsls(m2));  // false (equals 오버라이딩 안하면 false)

[DB에서는 id가 같으면 같은 row로 인식하지만, Java에선 new로 만들면 무조건 다른 객체]

데이터베이스이 같은 로우를 조회할 때마다 같은 인스턴스를 반환하도록 구현하는 것은 어렵다
트랜잭션이 동시에 실행되는 상황까지 고려하면 문제는 더 어렵다

JPA와 비교
JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다

JPA는 자바 ORM 기술에 대한 API 표준 명세다.
인터페이스를 모아둔 것
JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야 한다
[하이버네이트], [이클립스링크], [DataNucleus].
