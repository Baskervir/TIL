# 연관관계 매핑 기초

## 객체와 테이블의 연관관계 차이

- **객체**는 참조(reference)를 통해 연관관계를 맺는다.  
  예: `member.setTeam(team);`

- **테이블**은 외래 키(Foreign Key)를 통해 연관관계를 맺는다.  
  예: `TEAM_ID` 컬럼

- 객체는 **기본적으로 단방향** 참조만 가진다.

- **양방향 연관관계**를 만들기 위해서는 반대쪽에도 필드를 추가해야 한다.  
  예: `Team` → `List<Member>`
  > 이 경우 실질적으로는 단방향 연관관계 2개를 동시에 유지하는 셈이다.

---

## 연관관계 매핑시 고려할 사항
+ 다중성
+ 양방향, 단방향
+ 연관관계의 주인

### 다중성
+ 다대일
+ 일대다
+ 일대일
+ 다대다

### 단방향, 양방향
+ 테이블에서는 외래 키 하나로 양방향 조인이 가능하다
+ 객체는 참조용 필드를 가지고 있는 객체만 연관된 객체 조회 가능

### 연관 관계의 주인
+ 데이터베이스는 외래 키 하나로 두 테이블이 연관관계를 맺느다
+ 엔티티는 양방향으로 매핑하면 2곳에서 서로를 참조한다
+ 외래 키를 관리하는 곳이 주인이 된다
+ 주인이 아니면 mappedBy 속성을 사용하고, 연관관계의 주인 필드 이름을 값으로 넣는다

`다(N)가 연관관계의 주인이다`

---
# 다대일
## 다대일 + 단방향
+ A.b로 B엔티티 참조 가능
+ B에는 A를 참조하는 필드가 없다
+ `@JoinColumn(name= "B_ID)`를 사용하여 A.b 필드를 B_ID 외래 키와 매핑한다
+ A.b 필드로 A테이블의 B_ID 외래 키를 관리한다

## 다대일 양방향
+ 양방향은 외래 키가 있는 쪽이 주인이 된다
+ 양방향 연관관계는 항상 서로를 참조해야 한다
  + 연관관계 편의 메서드를 작성한다 / setB(), addA() } 양쪽에 작성시 무한루프에 주의한다

---

# 일대다
## 일대다 + 단방향
+ B.a로 A테이블의 B_ID를 관리한다 (외래 키)
+ 항상 다(N)쪽에 외래 키가 존재한다 (주인)
`이 매핑은 반대쪽 테이블에 있는 외래 키를 관리한다`

#### 일대다 단방향 매핑의 단점
+ 매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다
  + 주 테이블에 외래 키가 있으면, 엔티티의 저장과 연관관계 처리를 `INSERT SQL` 한 번으로 처리가 가능하다
  + 대상 테이블에 외래 키가 있으면 연관관계 처리를 위한 `UPDATE SQL`을 추가로 처리해야 한다
`일대다 단방향 매핑보다 다대일 양방향 매핑을 사용하자`

`일대다 양방향 매핑은 존재하지 않으며, 다대일 양방향 매핑을 사용해야 한다`
  + 일대다 매핑이 불가능한 것은 아니다
  + 일대다 매핑 반대편에 같은 외래키를 사용하는 다대일 단방향 매핑을 읽기 전용으로 하나 추가하면 된다
    + 일대다 양방향 매핑이라기보다 일대다 단방향 매핑 반대편에 다대일 단방향 매핑을 읽기 전용으로 추가
    + 일대다 양방향 처럼 보이도록 하는 방법 / 일대다 단방향 매핑이 가지는 단점을 그대로 가진다

---

# 일대일
+ 양쪽이 서로 하나의 관계만 가진다
+ 일대일 관계는 반대도 일대일 관계다
+ 주 테이블이나 대상 테이블 둘 중 어느 곳이나 외래 키를 가질 수 있다 (양쪽 조회 가능)

## 일대일 + 주 테이블에 외래 키 + 단방향
+ 객체 매핑에 `@OneToOne`사용
+ 데이터베이스 외래 키에 유니크 제약 조건 사용
+ 다대일 단방향과 비슷하다

## 일대일 + 주 테이블에 외래 키 + 양방향
+ 양방향 관계이므로 주인이 필요하다
+ 주 테이블이 외래 키를 가지고 있으르모 주인이 된다
+ 반대 매핑 테이블에 `mappedBy`를 선언한다

## 일대일 + 대상 테이블에 외래 키 + 단방향
+ `JPA`에서 지원하지 않는다
+ 단방향 관계를 반대 방향으로 수정해야 한다
+ 양방향으로 변경 + 주인 변경 필요

## 일대일 + 대상 테이블에 외래 키 + 양방향
+ 주 엔티티 대신에 대상 엔티티에 외래 키를 추가하여 대상 엔티티를 주인으로 만든다

---

# 다대다
+ 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계 표현 불가능
+ 일대다, 다대일 관계로 풀어주는 연결 테이블을 사용한다

## 다대다 + 단방향
+ 두 엔티티가 서로 다수의 인스턴스를 가질 수 있는 관계
+ 주 테이블은 대상 테이블을 알고, 대상 테이블은 주 테이블을 알지 못한다
+ 데이터베이스에서는 연결 테이블로 매핑된다
+ 필요에 따라 `중간 연결 엔티티`를 직접 만든다

`한 객체가 다수의 다른 객체를 참조하고, 연결은 별도 테이블이 관리하는 구조`다

## 다대다 + 양방향
+ 양쪽 객체 모두 서로를 참조하는 구조다
+ 객체 A는 객체 B를 참조하고, 객체 B도 객체 A를 참조한다
+ 관계형 데이터베이스는 여전히 직접 다대다 표현이 불가능하다
  + `연결 테이블`이 필요하다
  + 연결 테이블에는 양쪽 객체를 모두 참조하는 `두 개의 외래 키(FK)`가 존재한다
+ 다대다 양방향 매핑에서는 두 객체 모두 컬렉션(List/Set)을 가진다
  + 한쪽을 `연관관계의 주인`으로 지정하고, 다른쪽은 `mappedBy`속성으로 주인을 지정한다
+ 주인 테이블에는 `@JoinTable`을 사용한다
+ 주인 쪽 엔티티가 연결 테이블에 대한 실제 변경 객체

```declarative
연관관계 주인은 꼭 하나만 존재한다
주인만 데이터베이스에 실제 반영할 수 있다
mappedBy 쪽은 단순히 "읽기" 관점에서만 사용된다
```

---

# 다대다 : 매핑의 한계와 극복, 연결 엔티티 사용
## 연결 테이블에 추가 정보 필요는 일반적이다
+ `@ManyToMany`사용 시, JPA가 연결 테이블을 자동적으로 만들어준다(개발자 관여 불가)
  + 이런 경우, 추가적인 내용 삽입이 불가능하다 (실질적으로 필요한 경우가 대부분이다)
+ 추가 내용을 다루는 연결 테이블을 만들기 위해서는 개발자가 직접 연결 테이블을 만들어야 한다
  + `@ManyToMany`애너테이션을 지운다 -> 연결 테이블을 엔티티로 승격시킨다
  + 엔티티 간의 관계도 테이블 관계처럼 다대다에서 일대다, 다대일 관계로 풀어야 한다
  + 연결 엔티티는 `기본 키 + 외래 키`를 한번에 매핑한다
  + `@IdClass`를 사용해서 복합 기본 키를 매핑한다

---

# JPA 연관관계 애너테이션
| 연관관계 종류 | 주요 애너테이션    | 설명 | 특징                       |
| --- |-------------| --- |--------------------------|
| 일대일 | @OneToOne   | 하나의 객체가 하나의 객체를 참조 | - 양쪽 모두 `@OneToOne`사용 가능<br> - `mappedBy`로 주인 지정 가능 |
| 다대일 | @ManyToOne  | 여러 객체가 하나의 객체를 참조 | - 항상 `N` 쪽이 주인<br> - 주 테이블에 외래 키 존재 |
| 일대다 | @OneToMany  | 하나의 객체가 여러 객체를 참조 | - 반대쪽이 `@ManyToOne`으로 추인이 되어야 정상 매핑<br> - 단독 사용 시 추가 설정 필요 |
| 다대다 | @ManyToMany | 여러 객체가 여러 객체를 참조 | - 연결 테이블 필요<br> - 한쪽은 `@JoinTable`, 다른쪽은 `mappedBy`사용 |

# 추가적으로 알아야 할 애너테이션
| 애너테이션       | 주 용도 | 사용 위치 |
|-------------| --- | --- |
| @JoinColumn | 외래 키(FK) 매핑 설정 | 다대일, 일대일 주인 쪽 |
| @JoinTable  | 연결 테이블 설정 | 다대다 주인 쪽 |
| mappedBy    | 연관관계 주인 아닌 쪽에서 사용<br> 주인을 가리킨다 | 양방향 관계의 비주인 쪽 |
| `cascade`옵션 | 연관 객체에 대한 연쇄 작업 설정<br> (persist, remove 등) | 관계를 맺은 양쪽 엔티티 |
| `fetch`옵션   | 연관 객체를 즉시 로딩(EAGER)할지 지연 로딩(LAZY)할지 결정 | 모든 연관관계 |
