*** 기본 키 매핑 ***
직접 할당 : 기본 키를 애플리케이션에 직접 할당
자동 생성 : 대리 키 사용 방식
    IDENTITY : 기본 키 생성을 데이터베이스에 위임한다
    SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다
    TABLE : 키 생성 테이블을 사용한다

*** 기본 키 직업 할당 전략 ***
[@Id]
em.persist()로 엔티티를 저장하기 전에 애플리케이션에서 기본 키를 직접 할당하는 방법

*** IDENTITY 전략 ***
기본 키 생성을 데이터베이스에 위임하는 전략
MySQL의 AUTO_INCREMENT 기능
@GeneratedValue (strategy = GenerationYtpe.IDENTITY)

[엔티티가 영속 상태가 되려면 식별자가 반드시 필요하다], [IDENTITY 식별자 생성 전략은 엔티티를 DB에 저장해야 식별자를 구할 수 있다]
= 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다

*** SEQUENCE 전략 ***
유일값을 순서대로 생성하는 특별한 데이터베이스 오브젝트다
    > 우선 사용할 데이터베이스를 매핑해야 한다 / 시퀀스 생성기를 실제 데이터베이스의 시퀀스와 매핑한다
    > em.persist()를 호출할 때, 먼저 데인터베이스 시퀀스를 사용
    > 식별자를 조회한다
    > 식별자를 엔티티에 할당
    > 엔티티를 영속성 컨텍스트에 저장한다
    > 트랜잭션을 커밋해서 flush가 일어나면 엔티티를 데이터베이스에 저장한다

*** TABLE 전략 ***
키 생성 전용 테이블을 하나 만들고 여기에 이름과 값으로 사용할 Column을 만들어 데이터베이스 시퀀스를 흉내내는 전략
모든 데이터베이스에 적용할 수 있다
    > 키 생성 용도로 사용할 테이블을 만든다
    > @TableGenerator를 사용해서 테이블 키 생성기를 등록한다
    > MY_SEQUENCES 테이블을 키 생성용 테이블로 매핑한다
    > TABLE 전략을 사용하기 위해 GenerationType.TABLE을 선택한다
    > @GeneratedValue.genetator에 테이블 키 생성기를 저장한다

*** AUTO 전략 ***
GenerationType.AUTO는 선택한 데이터베이스 방언에 따라 위 전략들 중 하나를 자동으로 선택한다

------------------------------------------------------------------------------------------------------------------

영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다
엔티티를 영속 상태로 만들기 위해 반드시 식별자 값이 있어야 한다

*** 전략별 식별자 할당 ***
[직접 할당] 
    em.persist() 호출하기 전에 애플리케이션에서 직접 식별자 값을 할당해야 한다
[SEQUENCE]
    데이터베이스 시퀀스에서 식별자 값을 획득 > 영속성 컨텍스트에 저장
[TABLE]
    데이터베이스 시퀀스 생성용 테이블에서 식별자 값을 획득 > 영속성 컨텍스트에 저장
[IDENTITY]
    데이터베이스에 엔티티를 저장해서 식별자 값을 획득 > 영속성 컨텍스트에 저장 // 테이블에 데이터를 저장해야 식별자 값 획득 가능