# 고급 매핑
+ 상속 관계 매핑
+ @MappedSuperclass
+ 복합 키와 식별 관계 매핑
+ 조인 테이블
+ 엔티티 하나에 여러 테이블 매핑하기

---

# 상속 관계 매핑
+ 데이터베이스에는 객체지향 언어에서 다루는 상속 개념이 없다
  + Super-Type Sub-Type Relationship 모델링 기법
    + 상속과 가장 유사하다
## 상속 관계 매핑 전략
1. 각각의 테이블로 변환
   + 각각을 모두 테이블로 만든다
   + 조회할 때 조인 사용 / JPA 에서는 조인 전략
2. 통합 테이블로 변환
   + 테이블을 하나만 사용해서 통합 / JPA 에서는 단일 테이블 전략
3. 서브타입 테이블로 변환
   + 서브타입마다 하나의 테이블을 만든다 / JPA 에서는 구현클래스마다 테이블 전략

---

## 조인 전략
+ 엔티티 각각을 모두 테이블로 만든다
+ 자식 테이블이 부모 테이블의 기본 키를 받아서 `기본 키 + 외래 키`로 사용한다
   + 조회할 때 조인을 자주 사용한다
+ `InheritanceType.JOINED`선택
`객체는 타입 구분 가능 <-> 테이블은 불가능`, `타입을 구분하는 컬럼 추가 필요`

### 조인 전략 정리
+ 장점
  + 테이블이 정규화 된다
  + 외래 키 참조 무결성 제약조건 활용 가능
  + 저장공간의 효율적인 사용 가능
+ 단점
  + 조회 시 많은 조인 사용 (성능저하)
  + 조회 쿼리가 복잡하다
  + 데이터 등록 시 `INSERT SQL` 두 번 실행

---

## 단일 테이블 전략
+ 테이블 하나만 사용
+ 구분 컬럼(DTYPE)으로 저장된 자식 데이터 구분
+ 조회 시 조인 사용 X = 빠르다
+ 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다
+ `InheritanceType.SINGLE_TABLE`선택
```declarative
Book 엔티티를 저장하면 ITEM 테이블의<br> AUTHOR, ISBN 컬럼만 사용하고 다른 엔티티와<br> 매핑된 ARTIST, DIRECTOR, ACTOR 컬럼은<br> 사용하지 않으므로 null 입력된다
```

### 단일 테이블 전략 정리
+ 장점
  + 조회 시 조인 사용 X = 빠르다
  + 조회 쿼리가 단순하다
+ 단점
  + 자식 엔티티가 매핑한 컬럼은 모두 null 허용
  + 단일 테이블에 모두 저장
    + 테이블이 커질 수 있다 = 상황에 따라 성능 저하 발생

`구분 컬럼을 반드시 사용해야 한다` > @DiscriminatorColumn
`@DiscriminatorValue 지정 X` > 기본으로 엔티티 이름 사용

---

## 구현 클래스마다 테이블 전략
+ 자식 엔티티마다 테이블을 만든다
+ 자식 테이블 각각에 필요한 컬럼이 모두 있다
+ `InheritanceType.TABLE_PER_CLASS` 선택

### 구현 클래스마다 테이블 전략 정리
+ 장점
  + 서브타입을 구분해서 처리할 때 효과적이다
  + not null 제약조건 사용 가능
+ 단점
  + 여러 자식 테이블을 함께 조회할 때 성능 저하 > SQL에 UNION을 사용해야 한다
  + 자식 테이블을 통합해서 쿼리하기 어렵다
`조인 or 단일 테이블 전략이 일반적이다`

---

# @MappedSuperclass
+ 부모 클래스는 테이블과 매핑하지 않으며, 상속받은 자식 클래스에게 매핑 정보만 제공하고 싶을 때 사용
+ @Entity는 실제 테이블과 매핑되지만, @MappedSuperclass는 실제 테이블과 매핑되지 않는다
+ 단순히 매핑 정보를 상속할 목적으로만 사용

+ 부모로부터 상속받은 매핑정보를 재정의하려면
  + `@AttributeOverrides`,`@AttribureOverride`사용
+ 연관관계 재정의
  + `@AssociationOverrides`, `@AssociationOverride`사용

`테이블과 매핑되지 않고 자식 클래스에 매핑 정보를 상속하기 위해 사용한다`
`@MappedSuperclass로 지정한 클래새는 엔티티가 아니므로, em.find()나 JPQL에서 사용 불가`
`이 클래스를 직접 생성해서 사용하는 일은 거의 없으므로 추상 클래스로 만드는 것을 권장`

---

# 복합 키와 식별 관계 매핑
## 식별 관계 vs 비식별 관계
+ 식별 관계
  + 부모 테이블의 기본 키를 내려받아 자식 테이블의 `기본 키 + 외래 키`로 사용하는 관계
+ 비식별 관계
  + 부로 테이블의 기본 키를 받아서 자식 테이블의 외래키로만 사용하는 관계
    + 필수적 비식별 관계
      + 외래 키에 null 허용 X
      + 연관관계를 필수적으로 맺어야 한다
    + 선택적 비식별 관계
      + 외래 키에 null 허용 O
      + 연관관계를 맺을지 말지 선택할 수 있다
`식별 or 비식별 중 하나를 선택해야 한다`
`비식별 관계를 주로 사용하고 필요한 곳에 식별 관계를 사용한다`

## 복합 키 : 비식별 관계 매핑
+ 둘 이상의 컬럼으로 구성된 복합 기본 키는 매핑 오류 발생
  + 별도의 식별자 클래스르르 만들어야 한다
+ JPA는 영속성 컨텍스트에 엔티티를 보관할 때, 엔티티의 식별자를 키로 사용한다
  + 식별자 구분을 위해 `equals`와 `hashcode`사용
`식별자 필드가 2개 이상이면 별도의 식별자 클래스를 만들고, 그 곳에 equals와 hashcode를 구현한다`

### @IdClass
+ `식별자 클래스의 속성명`과 `엔티티에서 사용하는 식별자의 속성명`이 같아야 한다
+ `Serializable 인터페이스`를 `구현`해야 한다
+ `equals`, `hashcode`를 구현해야 한다
+ `기본 생성자`가 있어야 한다
+ 식별자 클래스는 `public`이어야 한다

### @EmbeddedId
+ `@EmbeddedId 어노테이션`을 붙여야 한다
+ `Serialization 인터페이스`를 `구현`해야 한다
+ `equals`, `hashcode`를 구현해야 한다
+ `기본 생성자`가 있어야 한다
+ 식별자 클래스는 `public`이어야 한다

`복합 키는 equals()와 hashcode()를 필수적으로 구현해야 한다`

## 복합 키 : 식별 관계 매핑
+ 자식 테이블은 부로 테이블의 기본 키를 포함해서 복합 키를 구성해야 한다
    + `@IdClass`나 `@EmbeddedId`를 사용해서 식별자를 매핑해야 한다

### @IdClass와 식별 관계
+ 식별 관계는 기본 키와 외래 키를 같이 매핑해야 한다
+ 식별자 매핑인 `@Id`와 연관관계 매핑인 `@ManyToOne`을 같이 사용하면 된다

### @EmbeddedId와 식별 관계
+ 식별 관계로 사용할 연관관계의 속성에 `@MapsId`를 사용하면 된다
+ `@IdClass`와 달리 `@Id` 대신 `@MapsId` 사용
  + 외래 키와 매핑한 연관관계를 기본 키에도 매핑하겠다는 뜻이다
+ 속성값은 `@EmbeddedId`를 사용한 식별자 클래스의 기본 키 필드를 지정하면 된다