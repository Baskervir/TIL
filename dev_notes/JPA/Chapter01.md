SQL을 직접 다룰때 발생하는 문제점


[개요] 
데이터베이스에 데이터를 관리하려면 SQL을 사용해야 한다.
JDBC API를 사용해서 SQL을 데이터베이스에 전달

[항목1]
반복되는 문제점
테이블 이미 개발되어 있다는 가정하에 CRUD기능을 개발(회원관리기능)
먼저 Member객체를 만든다
객체를 데이터베이스에 관리할 목적으로 회원용 DAO(데이터 접근 객체)를 만든다

MemberDAO 의 find() 메서드를 완서앟여 회우너 조회 기능을 개발한다
    1. 회원 조회용 SQL을 작성
    2. JDBC API를 사용해서 SQL을 실행
    3. 조회 결과를 Member객체로 매핑
= "회원 조회" 가능해졌다.

회원 등록 기능을 추가
    1. 회원 등록용 SQL을 작성
    2. 회원 객체의 값을 꺼내서 등록 SQL에 전달
    3. JDBC API를 사용하여 SQL을 실행
= "회원 등록" 가능해졌다.

회원을 수정, 삭제 하는 기능 추가
위와 같은 작업을 반복해야 할 것이다

회원 객체를 데이터베이스가 아닌 자바 컬렉션에 보관한다면? > 컬렉션은 다음 한 줄로 객체를 저장할 수 있다
    list.add(member);
데이터베이스는 객체 구조와는 다른 데이터 중심의 구조를 가지므로 객체를 데이터베이스에 직접 저장, 조회 할 수 없다.
따라서 객체지향 App과 DB 중간에서 SQL과 JDBC API를 사용해서 변환 작업을 해줘야 한다.

[문제점]객체를 데이터베이스에 CRUD하려면 너무 많은 SQL과 JDBC API를 코드로 작성한다

[항목]
SQL에 의존적인 개발

회원의 연락처도 함께 저장해달라는 요구사항이 추가되었다.

[등록 코드 변경]
dto에 객체 추가
연락처 저장 할 수 있도록 INSERT SQL을 수정
[String sql = "INSERT INTO MEMBER(MEMBER_ID, NAME, TEL) VALUE(?,?,?)";]
연락처를 데이터베이스에 저장하기 위해 SQL과 JDBC API를 수정했다

[조회 코드 변경]
조회용 SQL 수정
[SELECT MEMBER_ID, NAME, TEL FROM MEMBER WHERE MEMBER_ID = ?]
연락처의 조회 결과를 Member 객체에 추가로 매핑한다
[...
String tel = rs.getString("TEL");
member.setTel(tel);
...]
이제서야 연락처 값이 화면에 출력된다.

[수정 코드 변경],[삭제 코드 변경]

[연관된 객체]
회원은 어떤 한 팀에 필수로 소속되어야 한다는 요구사항 추가

[문제점]
    A 객체가 연관된 B 객체를 사용 가능한지 여부는 사용하는 SQL에 달렸다
    데이터 접근 계츨을 사용해서 SQL을 숨겨도 어쩔 수 없이 DAO를 열어서 어떤 SQL이 실행되는지 확인해야 한다

Member, Team처럼 비즈니스 요구사항을 모델링한 객체를 [엔티티]라 한다

[SQL에 모든 것을 의존하는 상황 > 엔티티 신뢰 및 사용 불가?]

SQL의존이란?
    애플리케이션 로직이나 상태 판탄을 DB 쿼리로 직접 수행하고, 애플리케이션(자바 코드, 엔티티)에서는
    그냥 그 결과만 받아서 보여주는 경우

엔티티는 무지해진다
    [엔티티]는 본래 도메인 개념을 담고, 내부 상태와 로직을 책임지는 객체
    하지만 SQL 위주로 처리하면:
        엔티티는 그저 DB 테이블의 데이터 구조일 뿐
        중요한 판단(활성 사용자 여부, 상태 변경, 비즈니스 조건)은 모두 쿼리로 처리됨
        비즈니스 로직이 DB로 흧어지고, Java 코드는 "데이터 그릇"일 뿐이 된다

    [결론]
        테스트할 수 없다 (엔티티 단위 테스트 불가)
        재사용 불가 (비즈니스 판단이 SQL 안에 박혀있다
        도메인 규칙 변경 시 유지보수 어렵다

신뢰 불가능한 이유 요약
    [도메인 지식 없음] : 엔티티에 비즈니스 의미가 없다. 조건, 정책 모두 SQL에서만 존재
    [상태 추론 불가] : 자바 객체를 보더라도 어떤 상태인지 알 수 없다
    [테스트 불가] : 객체 단위 테스트가 아닌, DB 세팅 + SQL 테스트가 필요
    [변경에 취약] : 로직이 SQL에 하드코딩되어 수정이 어렵고 추적도 힘들다

[개선하기]
    도메인 로직은 Entity / Domain / Service Layer에서 처리
    SQL은 오직 데이터 조회 / 저장 역할만 한다

SQL 중심의 구조는 애플리케이션 계층의 역할을 약화
도메인 모델은 단순 데이터 구조가 된다
객체지향의 가장 큰 장점인 [행위와 데이터의 응집]을 잃는다


진정한 의미의 계층 분할이 어렵다. [?]
엔티티를 신뢰할 수 없다. [?]
SQL에 의존적인 개발을 피하기 어렵다 [v]

[항목]
JPA와 문제 해결

JPA가 문제를 어떻게 해결하는가?

직업 SQL 작성 X -> JPA가 제공하는 API를 사용
[개발자 대신 적절한 SQL을 생성하여 데이터베이스에 전달한다.]

[저장 기능]
jpa.persist(member); //저장
JPA가 객체와 매핑정보를 보고 적절한 INSERT SQL을 생성 > 데이터에비으세 전달

    [매핑 정보] : 어떤 객체를 어떤 테이블에 관리할지 정의한 정보

[조회 기능]
String memberId = "helloId";
Member member = jpa.find(Member.class, memberId);   //조회

[수정 기능]
Member member = jpa.find(Member.class, memberId);
member.setName("이름변경"); //수정
JPA는 별도의 수정 메서드를 제공하지 않는다.
객체를 조회해서 값을 변경해야 한다.
트랜잭션을 커밋할 때, 데이터베이스에 적절한 UPDATE SQL이 전달된다.

[객체와 관계형 데이터베이스의 패러다임 차이??]

[패러다임 불일치]
현대의 복잡한 애플리케이션은 대부분 객체지향 언어로 개발
[정의한 도메인 모델을 저장할 때 문제 발생]
예를 들어 특정 유저가 시스템에 회원 가입하면 회원이라는 객체 인스턴스를 생성한 후에 이 객체를 메모리가 아닌 어딘가에 영구 보관해야 한다.

객체는 속성(필드)과 기능(메서드)를 가진다.
객체의 기능은 클래스에 정의되어 있다

객체가 단순하면 객체의 모든 속성 값을 꺼내서 파일이나 데이터베이스에 저장하면 된다.
하지만, 부모 객체를 상속받았거나, 다른 객체를 참조하고 있다면 객체의 상태를 저장하기 어렵다.
회원 객체가 팀 객체를 참조하고 있다면, 회원 객체를 저장할 때 팀 객체도 함께 저장해야 한다.

[직렬화 기능??]

[관계형 데이터베이스는 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구한다.],
[객체지향에서 말하는 추상화, 상속, 다형성 같은 개념이 없다.]

[객체]와 [관계형 데이터베이스]는 지향하는 목적이 서로 다르다 > 기능과 표현법도 다르다
> "패러다임 불일치"

[패러다임 불일치로 인한 문제점]
상속
    객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없다
    슈퍼타입&서브타입 관계를 사용하면 상속과 유사한 형태로 테이블 설계[는] 가능

